#!/usr/bin/env python
# -*- coding: utf-8 -*-
from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()
from .models import Group, Firma, User
from random import randint


def populate_db(num_users=5, num_groups=15, num_firms=5):
    """
    Fills the data will fake data.
    """
    from faker import Factory
    #from faker.providers import internet as faker_internet

    fake = Factory.create()

    admin_username = 'cburmeister'
    admin_email = 'cburmeister@discogs.com'
    admin_password = 'test123'
    users = []
    for _ in range(int(num_users)):
        users.append(
            User(
                fake.name().split(' ')[0],
                fake.email(),
                fake.word() + fake.word(),
                fake.word(),
                password=fake.word(),
                remote_addr=fake.ipv4(network=False),
                active=True
            )
        )

    """users.append(
        User(
            admin_username,
            admin_email,
            admin_password,
            fake.ipv4(),
            active=True,
            is_admin=True
        )
    )"""

    for user in users:
        db.session.add(user)

    firms = []
    for _ in range(int(num_firms)):
        firms.append(
            Firma(
                fake.word(),
                fake.word(),
                fake.address(),
                str(randint(100000000, 999999999))
            )
        )

    db.session.commit()


class DataTable(object):
    """
    Represents a sortable, filterable, searchable, and paginated set of data,
    generated by arguments in the request values.

    TODO:
    - flask-ext for access to request values?
    - throw some custom errors when getting fields, etc
    - get rid of the 4 helpers that do the same thing
    - should this generate some html to help with visualizing the data?
    """
    def __init__(self, model, columns, sortable, searchable, filterable, limits, request):
        self.model = model
        self.query = self.model.query
        self.columns = columns
        self.sortable = sortable
        self.orders = ['asc', 'desc']
        self.searchable = searchable
        self.filterable = filterable
        self.limits = limits

        self.get_selected(request)

        for f in self.filterable:
            self.selected_filter = request.values.get(f.name, None)
            self.filter(f.name, self.selected_filter)
        self.search(self.selected_query)
        self.sort(self.selected_sort, self.selected_order)
        self.paginate(self.selected_page, self.selected_limit)

    def get_selected(self, request):
        self.selected_sort = request.values.get('sort', self.sortables[0])
        self.selected_order = request.values.get('order', self.orders[0])
        self.selected_query = request.values.get('query', None)
        self.selected_limit = request.values.get('limit', self.limits[1], type=int)
        self.selected_page = request.values.get('page', 1, type=int)

    @property
    def _columns(self):
        return [x.name for x in self.columns]

    @property
    def sortables(self):
        return [x.name for x in self.sortable]

    @property
    def searchables(self):
        return [x.name for x in self.searchable]

    @property
    def filterables(self):
        return [x.name for x in self.filterable]

    @property
    def colspan(self):
        """Length of all columns."""
        return len(self.columns) + len(self.sortable) + len(self.searchable)

    def sort(self, field, order):
        """Sorts the data based on a field & order."""
        if field in self.sortables and order in self.orders:
            field = getattr(getattr(self.model, field), order)
            self.query = self.query.order_by(field())

    def filter(self, field, value):
        """Filters the query based on a field & value."""
        if field and value:
            field = getattr(self.model, field)
            self.query = self.query.filter(field==value)

    def search(self, search_query):
        """Filters the query based on a list of fields & search query."""
        if search_query:
            search_query = '%%%s%%' % search_query
            from sqlalchemy import or_
            fields = [getattr(self.model, x) for x in self.searchables]
            self.query = self.query.filter(or_(*[x.like(search_query) for x in fields]))

    def paginate(self, page, limit):
        """Paginate the query based on a page & limit."""
        self.query = self.query.paginate(page, limit)
